"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1879],{80812:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,a,r){return(0,i.default)(e,t,[{type:r?"CommentLine":"CommentBlock",value:a}])};var i=a(80849)},80849:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,a){if(!a||!e)return e;let i=`${t}Comments`;return e[i]?"leading"===t?e[i]=a.concat(e[i]):e[i].push(...a):e[i]=a,e}},33647:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0,i.default)("innerComments",e,t)};var i=a(50998)},20781:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0,i.default)("leadingComments",e,t)};var i=a(50998)},98945:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0,i.default)("trailingComments",e,t)};var i=a(50998)},65886:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return(0,i.default)(e,t),(0,r.default)(e,t),(0,s.default)(e,t),e};var i=a(98945),r=a(20781),s=a(33647)},21718:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return i.COMMENT_KEYS.forEach(t=>{e[t]=null}),e};var i=a(19449)},93527:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WHILE_TYPES=t.USERWHITESPACABLE_TYPES=t.UNARYLIKE_TYPES=t.TYPESCRIPT_TYPES=t.TSTYPE_TYPES=t.TSTYPEELEMENT_TYPES=t.TSENTITYNAME_TYPES=t.TSBASETYPE_TYPES=t.TERMINATORLESS_TYPES=t.STATEMENT_TYPES=t.STANDARDIZED_TYPES=t.SCOPABLE_TYPES=t.PUREISH_TYPES=t.PROPERTY_TYPES=t.PRIVATE_TYPES=t.PATTERN_TYPES=t.PATTERNLIKE_TYPES=t.OBJECTMEMBER_TYPES=t.MODULESPECIFIER_TYPES=t.MODULEDECLARATION_TYPES=t.MISCELLANEOUS_TYPES=t.METHOD_TYPES=t.LVAL_TYPES=t.LOOP_TYPES=t.LITERAL_TYPES=t.JSX_TYPES=t.IMPORTOREXPORTDECLARATION_TYPES=t.IMMUTABLE_TYPES=t.FUNCTION_TYPES=t.FUNCTIONPARENT_TYPES=t.FOR_TYPES=t.FORXSTATEMENT_TYPES=t.FLOW_TYPES=t.FLOWTYPE_TYPES=t.FLOWPREDICATE_TYPES=t.FLOWDECLARATION_TYPES=t.FLOWBASEANNOTATION_TYPES=t.EXPRESSION_TYPES=t.EXPRESSIONWRAPPER_TYPES=t.EXPORTDECLARATION_TYPES=t.ENUMMEMBER_TYPES=t.ENUMBODY_TYPES=t.DECLARATION_TYPES=t.CONDITIONAL_TYPES=t.COMPLETIONSTATEMENT_TYPES=t.CLASS_TYPES=t.BLOCK_TYPES=t.BLOCKPARENT_TYPES=t.BINARY_TYPES=t.ACCESSOR_TYPES=void 0;var i=a(79398);t.STANDARDIZED_TYPES=i.FLIPPED_ALIAS_KEYS.Standardized,t.EXPRESSION_TYPES=i.FLIPPED_ALIAS_KEYS.Expression,t.BINARY_TYPES=i.FLIPPED_ALIAS_KEYS.Binary,t.SCOPABLE_TYPES=i.FLIPPED_ALIAS_KEYS.Scopable,t.BLOCKPARENT_TYPES=i.FLIPPED_ALIAS_KEYS.BlockParent,t.BLOCK_TYPES=i.FLIPPED_ALIAS_KEYS.Block,t.STATEMENT_TYPES=i.FLIPPED_ALIAS_KEYS.Statement,t.TERMINATORLESS_TYPES=i.FLIPPED_ALIAS_KEYS.Terminatorless,t.COMPLETIONSTATEMENT_TYPES=i.FLIPPED_ALIAS_KEYS.CompletionStatement,t.CONDITIONAL_TYPES=i.FLIPPED_ALIAS_KEYS.Conditional,t.LOOP_TYPES=i.FLIPPED_ALIAS_KEYS.Loop,t.WHILE_TYPES=i.FLIPPED_ALIAS_KEYS.While,t.EXPRESSIONWRAPPER_TYPES=i.FLIPPED_ALIAS_KEYS.ExpressionWrapper,t.FOR_TYPES=i.FLIPPED_ALIAS_KEYS.For,t.FORXSTATEMENT_TYPES=i.FLIPPED_ALIAS_KEYS.ForXStatement,t.FUNCTION_TYPES=i.FLIPPED_ALIAS_KEYS.Function,t.FUNCTIONPARENT_TYPES=i.FLIPPED_ALIAS_KEYS.FunctionParent,t.PUREISH_TYPES=i.FLIPPED_ALIAS_KEYS.Pureish,t.DECLARATION_TYPES=i.FLIPPED_ALIAS_KEYS.Declaration,t.PATTERNLIKE_TYPES=i.FLIPPED_ALIAS_KEYS.PatternLike,t.LVAL_TYPES=i.FLIPPED_ALIAS_KEYS.LVal,t.TSENTITYNAME_TYPES=i.FLIPPED_ALIAS_KEYS.TSEntityName,t.LITERAL_TYPES=i.FLIPPED_ALIAS_KEYS.Literal,t.IMMUTABLE_TYPES=i.FLIPPED_ALIAS_KEYS.Immutable,t.USERWHITESPACABLE_TYPES=i.FLIPPED_ALIAS_KEYS.UserWhitespacable,t.METHOD_TYPES=i.FLIPPED_ALIAS_KEYS.Method,t.OBJECTMEMBER_TYPES=i.FLIPPED_ALIAS_KEYS.ObjectMember,t.PROPERTY_TYPES=i.FLIPPED_ALIAS_KEYS.Property,t.UNARYLIKE_TYPES=i.FLIPPED_ALIAS_KEYS.UnaryLike,t.PATTERN_TYPES=i.FLIPPED_ALIAS_KEYS.Pattern,t.CLASS_TYPES=i.FLIPPED_ALIAS_KEYS.Class;let r=t.IMPORTOREXPORTDECLARATION_TYPES=i.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;t.EXPORTDECLARATION_TYPES=i.FLIPPED_ALIAS_KEYS.ExportDeclaration,t.MODULESPECIFIER_TYPES=i.FLIPPED_ALIAS_KEYS.ModuleSpecifier,t.ACCESSOR_TYPES=i.FLIPPED_ALIAS_KEYS.Accessor,t.PRIVATE_TYPES=i.FLIPPED_ALIAS_KEYS.Private,t.FLOW_TYPES=i.FLIPPED_ALIAS_KEYS.Flow,t.FLOWTYPE_TYPES=i.FLIPPED_ALIAS_KEYS.FlowType,t.FLOWBASEANNOTATION_TYPES=i.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation,t.FLOWDECLARATION_TYPES=i.FLIPPED_ALIAS_KEYS.FlowDeclaration,t.FLOWPREDICATE_TYPES=i.FLIPPED_ALIAS_KEYS.FlowPredicate,t.ENUMBODY_TYPES=i.FLIPPED_ALIAS_KEYS.EnumBody,t.ENUMMEMBER_TYPES=i.FLIPPED_ALIAS_KEYS.EnumMember,t.JSX_TYPES=i.FLIPPED_ALIAS_KEYS.JSX,t.MISCELLANEOUS_TYPES=i.FLIPPED_ALIAS_KEYS.Miscellaneous,t.TYPESCRIPT_TYPES=i.FLIPPED_ALIAS_KEYS.TypeScript,t.TSTYPEELEMENT_TYPES=i.FLIPPED_ALIAS_KEYS.TSTypeElement,t.TSTYPE_TYPES=i.FLIPPED_ALIAS_KEYS.TSType,t.TSBASETYPE_TYPES=i.FLIPPED_ALIAS_KEYS.TSBaseType,t.MODULEDECLARATION_TYPES=r},19449:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UPDATE_OPERATORS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.STATEMENT_OR_BLOCK_KEYS=t.NUMBER_UNARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.NOT_LOCAL_BINDING=t.LOGICAL_OPERATORS=t.INHERIT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.EQUALITY_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.COMMENT_KEYS=t.BOOLEAN_UNARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.BLOCK_SCOPED_SYMBOL=t.BINARY_OPERATORS=t.ASSIGNMENT_OPERATORS=void 0,t.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"],t.FLATTENABLE_KEYS=["body","expressions"],t.FOR_INIT_KEYS=["left","init"],t.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"];let a=t.LOGICAL_OPERATORS=["||","&&","??"];t.UPDATE_OPERATORS=["++","--"];let i=t.BOOLEAN_NUMBER_BINARY_OPERATORS=[">","<",">=","<="],r=t.EQUALITY_BINARY_OPERATORS=["==","===","!=","!=="],s=t.COMPARISON_BINARY_OPERATORS=[...r,"in","instanceof"],o=t.BOOLEAN_BINARY_OPERATORS=[...s,...i],n=t.NUMBER_BINARY_OPERATORS=["-","/","%","*","**","&","|",">>",">>>","<<","^"];t.BINARY_OPERATORS=["+",...n,...o,"|>"],t.ASSIGNMENT_OPERATORS=["=","+=",...n.map(e=>e+"="),...a.map(e=>e+"=")];let l=t.BOOLEAN_UNARY_OPERATORS=["delete","!"],p=t.NUMBER_UNARY_OPERATORS=["+","-","~"],d=t.STRING_UNARY_OPERATORS=["typeof"];t.UNARY_OPERATORS=["void","throw",...l,...p,...d],t.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]},t.BLOCK_SCOPED_SYMBOL=Symbol.for("var used to be block scoped"),t.NOT_LOCAL_BINDING=Symbol.for("should not be considered a local binding")},61388:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t="body"){let a=(0,i.default)(e[t],e);return e[t]=a,a};var i=a(74485)},94194:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,a){let l=[],p=!0;for(let d of t)if((0,r.isEmptyStatement)(d)||(p=!1),(0,r.isExpression)(d))l.push(d);else if((0,r.isExpressionStatement)(d))l.push(d.expression);else if((0,r.isVariableDeclaration)(d)){if("var"!==d.kind)return;for(let e of d.declarations){let t=(0,i.default)(e);for(let e of Object.keys(t))a.push({kind:d.kind,id:(0,n.default)(t[e])});e.init&&l.push((0,s.assignmentExpression)("=",e.id,e.init))}p=!0}else if((0,r.isIfStatement)(d)){let t=d.consequent?e([d.consequent],a):(0,o.buildUndefinedNode)(),i=d.alternate?e([d.alternate],a):(0,o.buildUndefinedNode)();if(!t||!i)return;l.push((0,s.conditionalExpression)(d.test,t,i))}else if((0,r.isBlockStatement)(d)){let t=e(d.body,a);if(!t)return;l.push(t)}else{if(!(0,r.isEmptyStatement)(d))return;0===t.indexOf(d)&&(p=!0)}return(p&&l.push((0,o.buildUndefinedNode)()),1===l.length)?l[0]:(0,s.sequenceExpression)(l)};var i=a(72130),r=a(63247),s=a(62112),o=a(10814),n=a(18852)},19757:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return("eval"===(e=(0,i.default)(e))||"arguments"===e)&&(e="_"+e),e};var i=a(94379)},74485:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if((0,i.isBlockStatement)(e))return e;let a=[];return(0,i.isEmptyStatement)(e)?a=[]:((0,i.isStatement)(e)||(e=(0,i.isFunction)(t)?(0,r.returnStatement)(e):(0,r.expressionStatement)(e)),a=[e]),(0,r.blockStatement)(a)};var i=a(63247),r=a(62112)},97886:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t=e.key||e.property){return!e.computed&&(0,i.isIdentifier)(t)&&(t=(0,r.stringLiteral)(t.name)),t};var i=a(63247),r=a(62112)},25198:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=a(63247);t.default=function(e){if((0,i.isExpressionStatement)(e)&&(e=e.expression),(0,i.isExpression)(e))return e;if((0,i.isClass)(e)?e.type="ClassExpression":(0,i.isFunction)(e)&&(e.type="FunctionExpression"),!(0,i.isExpression)(e))throw Error(`cannot turn ${e.type} to an expression`);return e}},94379:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){let t="";for(let a of e+="")t+=(0,r.isIdentifierChar)(a.codePointAt(0))?a:"-";return t=(t=t.replace(/^[-0-9]+/,"")).replace(/[-\s]+(.)?/g,function(e,t){return t?t.toUpperCase():""}),(0,i.default)(t)||(t=`_${t}`),t||"_"};var i=a(1820),r=a(69783)},13665:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var i=a(63247),r=a(18852),s=a(27580);function o(e,t=e.key){let a;return"method"===e.kind?o.increment()+"":(a=(0,i.isIdentifier)(t)?t.name:(0,i.isStringLiteral)(t)?JSON.stringify(t.value):JSON.stringify((0,s.default)((0,r.default)(t))),e.computed&&(a=`[${a}]`),e.static&&(a=`static:${a}`),a)}o.uid=0,o.increment=function(){return o.uid>=Number.MAX_SAFE_INTEGER?o.uid=0:o.uid++}},10191:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(!(null!=e&&e.length))return;let a=[],r=(0,i.default)(e,a);if(r){for(let e of a)t.push(e);return r}};var i=a(94194)},49649:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=a(63247),r=a(62112);t.default=function(e,t){let a;if((0,i.isStatement)(e))return e;let s=!1;if((0,i.isClass)(e))s=!0,a="ClassDeclaration";else if((0,i.isFunction)(e))s=!0,a="FunctionDeclaration";else if((0,i.isAssignmentExpression)(e))return(0,r.expressionStatement)(e);if(s&&!e.id&&(a=!1),!a){if(t)return!1;throw Error(`cannot turn ${e.type} to a statement`)}return e.type=a,e}},23007:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=a(1820),r=a(62112);t.default=function e(t){if(void 0===t)return(0,r.identifier)("undefined");if(!0===t||!1===t)return(0,r.booleanLiteral)(t);if(null===t)return(0,r.nullLiteral)();if("string"==typeof t)return(0,r.stringLiteral)(t);if("number"==typeof t){let e;if(Number.isFinite(t))e=(0,r.numericLiteral)(Math.abs(t));else{let a;a=Number.isNaN(t)?(0,r.numericLiteral)(0):(0,r.numericLiteral)(1),e=(0,r.binaryExpression)("/",a,(0,r.numericLiteral)(0))}return(t<0||Object.is(t,-0))&&(e=(0,r.unaryExpression)("-",e)),e}if("[object RegExp]"===s(t)){let e=t.source,a=/\/([a-z]*)$/.exec(t.toString())[1];return(0,r.regExpLiteral)(e,a)}if(Array.isArray(t))return(0,r.arrayExpression)(t.map(e));if(function(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return!1;let t=Object.getPrototypeOf(e);return null===t||null===Object.getPrototypeOf(t)}(t)){let a=[];for(let s of Object.keys(t)){let o;o=(0,i.default)(s)?(0,r.identifier)(s):(0,r.stringLiteral)(s),a.push((0,r.objectProperty)(o,e(t[s])))}return(0,r.objectExpression)(a)}throw Error("don't know how to turn this value into a node")};let s=Function.call.bind(Object.prototype.toString)},84785:(e,t,a)=>{var i=a(2818);Object.defineProperty(t,"__esModule",{value:!0}),t.patternLikeCommon=t.importAttributes=t.functionTypeAnnotationCommon=t.functionDeclarationCommon=t.functionCommon=t.classMethodOrPropertyCommon=t.classMethodOrDeclareMethodCommon=void 0;var r=a(64039),s=a(1820),o=a(69783),n=a(31690),l=a(19449),p=a(99875);let d=(0,p.defineAliasedType)("Standardized");d("ArrayExpression",{fields:{elements:{validate:(0,p.arrayOf)((0,p.assertNodeOrValueType)("null","Expression","SpreadElement")),default:i.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:["elements"],aliases:["Expression"]}),d("AssignmentExpression",{fields:{operator:{validate:i.env.BABEL_TYPES_8_BREAKING?Object.assign(function(){let e=(0,p.assertOneOf)(...l.ASSIGNMENT_OPERATORS),t=(0,p.assertOneOf)("=");return function(a,i,s){((0,r.default)("Pattern",a.left)?t:e)(a,i,s)}}(),{type:"string"}):(0,p.assertValueType)("string")},left:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertNodeType)("Identifier","MemberExpression","OptionalMemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,p.assertNodeType)("LVal","OptionalMemberExpression")},right:{validate:(0,p.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]}),d("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:(0,p.assertOneOf)(...l.BINARY_OPERATORS)},left:{validate:function(){let e=(0,p.assertNodeType)("Expression"),t=(0,p.assertNodeType)("Expression","PrivateName");return Object.assign(function(a,i,r){("in"===a.operator?t:e)(a,i,r)},{oneOfNodeTypes:["Expression","PrivateName"]})}()},right:{validate:(0,p.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]}),d("InterpreterDirective",{builder:["value"],fields:{value:{validate:(0,p.assertValueType)("string")}}}),d("Directive",{visitor:["value"],fields:{value:{validate:(0,p.assertNodeType)("DirectiveLiteral")}}}),d("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0,p.assertValueType)("string")}}}),d("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0,p.arrayOfType)("Directive"),default:[]},body:(0,p.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block","Statement"]}),d("BreakStatement",{visitor:["label"],fields:{label:{validate:(0,p.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),d("CallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0,p.assertNodeType)("Expression","Super","V8IntrinsicIdentifier")},arguments:(0,p.validateArrayOfType)("Expression","SpreadElement","ArgumentPlaceholder"),typeArguments:{validate:(0,p.assertNodeType)("TypeParameterInstantiation"),optional:!0}},{optional:{validate:(0,p.assertValueType)("boolean"),optional:!0},typeParameters:{validate:(0,p.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}},i.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,p.assertValueType)("boolean"),optional:!0}})}),d("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0,p.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),optional:!0},body:{validate:(0,p.assertNodeType)("BlockStatement")}},aliases:["Scopable","BlockParent"]}),d("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0,p.assertNodeType)("Expression")},consequent:{validate:(0,p.assertNodeType)("Expression")},alternate:{validate:(0,p.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]}),d("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0,p.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),d("DebuggerStatement",{aliases:["Statement"]}),d("DoWhileStatement",{builder:["test","body"],visitor:["body","test"],fields:{test:{validate:(0,p.assertNodeType)("Expression")},body:{validate:(0,p.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]}),d("EmptyStatement",{aliases:["Statement"]}),d("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0,p.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]}),d("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0,p.assertNodeType)("Program")},comments:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertEach)((0,p.assertNodeType)("CommentBlock","CommentLine")):Object.assign(()=>{},{each:{oneOfNodeTypes:["CommentBlock","CommentLine"]}}),optional:!0},tokens:{validate:(0,p.assertEach)(Object.assign(()=>{},{type:"any"})),optional:!0}}}),d("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertNodeType)("VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,p.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0,p.assertNodeType)("Expression")},body:{validate:(0,p.assertNodeType)("Statement")}}}),d("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0,p.assertNodeType)("VariableDeclaration","Expression"),optional:!0},test:{validate:(0,p.assertNodeType)("Expression"),optional:!0},update:{validate:(0,p.assertNodeType)("Expression"),optional:!0},body:{validate:(0,p.assertNodeType)("Statement")}}});let y=()=>({params:(0,p.validateArrayOfType)("Identifier","Pattern","RestElement"),generator:{default:!1},async:{default:!1}});t.functionCommon=y;let T=()=>({returnType:{validate:(0,p.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0,p.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0}});t.functionTypeAnnotationCommon=T;let u=()=>Object.assign({},y(),{declare:{validate:(0,p.assertValueType)("boolean"),optional:!0},id:{validate:(0,p.assertNodeType)("Identifier"),optional:!0}});t.functionDeclarationCommon=u,d("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","typeParameters","params","predicate","returnType","body"],fields:Object.assign({},u(),T(),{body:{validate:(0,p.assertNodeType)("BlockStatement")},predicate:{validate:(0,p.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}}),aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"],validate:i.env.BABEL_TYPES_8_BREAKING?function(){let e=(0,p.assertNodeType)("Identifier");return function(t,a,i){(0,r.default)("ExportDefaultDeclaration",t)||e(i,"id",i.id)}}():void 0}),d("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},y(),T(),{id:{validate:(0,p.assertNodeType)("Identifier"),optional:!0},body:{validate:(0,p.assertNodeType)("BlockStatement")},predicate:{validate:(0,p.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}})});let c=()=>({typeAnnotation:{validate:(0,p.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},optional:{validate:(0,p.assertValueType)("boolean"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0}});t.patternLikeCommon=c,d("Identifier",{builder:["name"],visitor:["typeAnnotation","decorators"],aliases:["Expression","PatternLike","LVal","TSEntityName"],fields:Object.assign({},c(),{name:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("string"),Object.assign(function(e,t,a){if(!(0,s.default)(a,!1))throw TypeError(`"${a}" is not a valid identifier name`)},{type:"string"})):(0,p.assertValueType)("string")}}),validate:i.env.BABEL_TYPES_8_BREAKING?function(e,t,a){let i=/\.(\w+)$/.exec(t);if(!i)return;let[,s]=i,n={computed:!1};if("property"===s){if((0,r.default)("MemberExpression",e,n)||(0,r.default)("OptionalMemberExpression",e,n))return}else if("key"===s){if((0,r.default)("Property",e,n)||(0,r.default)("Method",e,n))return}else if("exported"===s){if((0,r.default)("ExportSpecifier",e))return}else if("imported"===s){if((0,r.default)("ImportSpecifier",e,{imported:a}))return}else if("meta"===s&&(0,r.default)("MetaProperty",e,{meta:a}))return;if(((0,o.isKeyword)(a.name)||(0,o.isReservedWord)(a.name,!1))&&"this"!==a.name)throw TypeError(`"${a.name}" is not a valid identifier`)}:void 0}),d("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0,p.assertNodeType)("Expression")},consequent:{validate:(0,p.assertNodeType)("Statement")},alternate:{optional:!0,validate:(0,p.assertNodeType)("Statement")}}}),d("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0,p.assertNodeType)("Identifier")},body:{validate:(0,p.assertNodeType)("Statement")}}}),d("StringLiteral",{builder:["value"],fields:{value:{validate:(0,p.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),d("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0,p.chain)((0,p.assertValueType)("number"),Object.assign(function(e,t,a){(1/a<0||!Number.isFinite(a))&&Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${a}) instead.`)},{type:"number"}))}},aliases:["Expression","Pureish","Literal","Immutable"]}),d("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]}),d("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0,p.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]}),d("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Pureish","Literal"],fields:{pattern:{validate:(0,p.assertValueType)("string")},flags:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("string"),Object.assign(function(e,t,a){let i=/[^gimsuy]/.exec(a);if(i)throw TypeError(`"${i[0]}" is not a valid RegExp flag`)},{type:"string"})):(0,p.assertValueType)("string"),default:""}}}),d("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:(0,p.assertOneOf)(...l.LOGICAL_OPERATORS)},left:{validate:(0,p.assertNodeType)("Expression")},right:{validate:(0,p.assertNodeType)("Expression")}}}),d("MemberExpression",{builder:["object","property","computed",...i.env.BABEL_TYPES_8_BREAKING?[]:["optional"]],visitor:["object","property"],aliases:["Expression","LVal"],fields:Object.assign({object:{validate:(0,p.assertNodeType)("Expression","Super")},property:{validate:function(){let e=(0,p.assertNodeType)("Identifier","PrivateName"),t=(0,p.assertNodeType)("Expression"),a=function(a,i,r){(a.computed?t:e)(a,i,r)};return a.oneOfNodeTypes=["Expression","Identifier","PrivateName"],a}()},computed:{default:!1}},i.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,p.assertValueType)("boolean"),optional:!0}})}),d("NewExpression",{inherits:"CallExpression"}),d("Program",{visitor:["directives","body"],builder:["body","directives","sourceType","interpreter"],fields:{sourceType:{validate:(0,p.assertOneOf)("script","module"),default:"script"},interpreter:{validate:(0,p.assertNodeType)("InterpreterDirective"),default:null,optional:!0},directives:{validate:(0,p.arrayOfType)("Directive"),default:[]},body:(0,p.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block"]}),d("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:(0,p.validateArrayOfType)("ObjectMethod","ObjectProperty","SpreadElement")}}),d("ObjectMethod",{builder:["kind","key","params","body","computed","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},y(),T(),{kind:Object.assign({validate:(0,p.assertOneOf)("method","get","set")},i.env.BABEL_TYPES_8_BREAKING?{}:{default:"method"}),computed:{default:!1},key:{validate:function(){let e=(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),t=(0,p.assertNodeType)("Expression"),a=function(a,i,r){(a.computed?t:e)(a,i,r)};return a.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral"],a}()},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},body:{validate:(0,p.assertNodeType)("BlockStatement")}}),aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]}),d("ObjectProperty",{builder:["key","value","computed","shorthand",...i.env.BABEL_TYPES_8_BREAKING?[]:["decorators"]],fields:{computed:{default:!1},key:{validate:function(){let e=(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"),t=(0,p.assertNodeType)("Expression");return Object.assign(function(a,i,r){(a.computed?t:e)(a,i,r)},{oneOfNodeTypes:["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"]})}()},value:{validate:(0,p.assertNodeType)("Expression","PatternLike")},shorthand:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("boolean"),Object.assign(function(e,t,a){if(a){if(e.computed)throw TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");if(!(0,r.default)("Identifier",e.key))throw TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")}},{type:"boolean"})):(0,p.assertValueType)("boolean"),default:!1},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0}},visitor:["key","value","decorators"],aliases:["UserWhitespacable","Property","ObjectMember"],validate:i.env.BABEL_TYPES_8_BREAKING?function(){let e=(0,p.assertNodeType)("Identifier","Pattern","TSAsExpression","TSSatisfiesExpression","TSNonNullExpression","TSTypeAssertion"),t=(0,p.assertNodeType)("Expression");return function(a,i,s){((0,r.default)("ObjectPattern",a)?e:t)(s,"value",s.value)}}():void 0}),d("RestElement",{visitor:["argument","typeAnnotation"],builder:["argument"],aliases:["LVal","PatternLike"],deprecatedAlias:"RestProperty",fields:Object.assign({},c(),{argument:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,p.assertNodeType)("LVal")}}),validate:i.env.BABEL_TYPES_8_BREAKING?function(e,t){let a=/(\w+)\[(\d+)\]/.exec(t);if(!a)throw Error("Internal Babel error: malformed key.");let[,i,r]=a;if(e[i].length>+r+1)throw TypeError(`RestElement must be last element of ${i}`)}:void 0}),d("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,p.assertNodeType)("Expression"),optional:!0}}}),d("SequenceExpression",{visitor:["expressions"],fields:{expressions:(0,p.validateArrayOfType)("Expression")},aliases:["Expression"]}),d("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0,p.assertNodeType)("Expression")}}}),d("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0,p.assertNodeType)("Expression"),optional:!0},consequent:(0,p.validateArrayOfType)("Statement")}}),d("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0,p.assertNodeType)("Expression")},cases:(0,p.validateArrayOfType)("SwitchCase")}}),d("ThisExpression",{aliases:["Expression"]}),d("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,p.assertNodeType)("Expression")}}}),d("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{block:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertNodeType)("BlockStatement"),Object.assign(function(e){if(!e.handler&&!e.finalizer)throw TypeError("TryStatement expects either a handler or finalizer, or both")},{oneOfNodeTypes:["BlockStatement"]})):(0,p.assertNodeType)("BlockStatement")},handler:{optional:!0,validate:(0,p.assertNodeType)("CatchClause")},finalizer:{optional:!0,validate:(0,p.assertNodeType)("BlockStatement")}}}),d("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!0},argument:{validate:(0,p.assertNodeType)("Expression")},operator:{validate:(0,p.assertOneOf)(...l.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]}),d("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!1},argument:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertNodeType)("Identifier","MemberExpression"):(0,p.assertNodeType)("Expression")},operator:{validate:(0,p.assertOneOf)(...l.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]}),d("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{declare:{validate:(0,p.assertValueType)("boolean"),optional:!0},kind:{validate:(0,p.assertOneOf)("var","let","const","using","await using")},declarations:(0,p.validateArrayOfType)("VariableDeclarator")},validate:i.env.BABEL_TYPES_8_BREAKING?(()=>{let e=(0,p.assertNodeType)("Identifier");return function(t,a,i){if((0,r.default)("ForXStatement",t,{left:i})){if(1!==i.declarations.length)throw TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`)}else i.declarations.forEach(t=>{t.init||e(t,"id",t.id)})}})():void 0}),d("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"):(0,p.assertNodeType)("LVal")},definite:{optional:!0,validate:(0,p.assertValueType)("boolean")},init:{optional:!0,validate:(0,p.assertNodeType)("Expression")}}}),d("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0,p.assertNodeType)("Expression")},body:{validate:(0,p.assertNodeType)("Statement")}}}),d("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{validate:(0,p.assertNodeType)("Expression")},body:{validate:(0,p.assertNodeType)("Statement")}}}),d("AssignmentPattern",{visitor:["left","right","decorators"],builder:["left","right"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},c(),{left:{validate:(0,p.assertNodeType)("Identifier","ObjectPattern","ArrayPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression")},right:{validate:(0,p.assertNodeType)("Expression")},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0}})}),d("ArrayPattern",{visitor:["elements","typeAnnotation"],builder:["elements"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},c(),{elements:{validate:(0,p.chain)((0,p.assertValueType)("array"),(0,p.assertEach)((0,p.assertNodeOrValueType)("null","PatternLike","LVal")))}})}),d("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["typeParameters","params","predicate","returnType","body"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},y(),T(),{expression:{validate:(0,p.assertValueType)("boolean")},body:{validate:(0,p.assertNodeType)("BlockStatement","Expression")},predicate:{validate:(0,p.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}})}),d("ClassBody",{visitor:["body"],fields:{body:(0,p.validateArrayOfType)("ClassMethod","ClassPrivateMethod","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","TSDeclareMethod","TSIndexSignature","StaticBlock")}}),d("ClassExpression",{builder:["id","superClass","body","decorators"],visitor:["decorators","id","typeParameters","superClass","superTypeParameters","mixins","implements","body"],aliases:["Scopable","Class","Expression"],fields:{id:{validate:(0,p.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0,p.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0,p.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,p.assertNodeType)("Expression")},superTypeParameters:{validate:(0,p.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0,p.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},mixins:{validate:(0,p.assertNodeType)("InterfaceExtends"),optional:!0}}}),d("ClassDeclaration",{inherits:"ClassExpression",aliases:["Scopable","Class","Statement","Declaration"],fields:{id:{validate:(0,p.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0,p.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0,p.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,p.assertNodeType)("Expression")},superTypeParameters:{validate:(0,p.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0,p.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},mixins:{validate:(0,p.assertNodeType)("InterfaceExtends"),optional:!0},declare:{validate:(0,p.assertValueType)("boolean"),optional:!0},abstract:{validate:(0,p.assertValueType)("boolean"),optional:!0}},validate:i.env.BABEL_TYPES_8_BREAKING?function(){let e=(0,p.assertNodeType)("Identifier");return function(t,a,i){(0,r.default)("ExportDefaultDeclaration",t)||e(i,"id",i.id)}}():void 0});let E=t.importAttributes={attributes:{optional:!0,validate:(0,p.arrayOfType)("ImportAttribute")},assertions:{deprecated:!0,optional:!0,validate:(0,p.arrayOfType)("ImportAttribute")}};d("ExportAllDeclaration",{builder:["source"],visitor:["source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({source:{validate:(0,p.assertNodeType)("StringLiteral")},exportKind:(0,p.validateOptional)((0,p.assertOneOf)("type","value"))},E)}),d("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:{declaration:(0,p.validateType)("TSDeclareFunction","FunctionDeclaration","ClassDeclaration","Expression"),exportKind:(0,p.validateOptional)((0,p.assertOneOf)("value"))}}),d("ExportNamedDeclaration",{builder:["declaration","specifiers","source"],visitor:i.env?["declaration","specifiers","source","attributes"]:["declaration","specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({declaration:{optional:!0,validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertNodeType)("Declaration"),Object.assign(function(e,t,a){if(a&&e.specifiers.length)throw TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");if(a&&e.source)throw TypeError("Cannot export a declaration from a source")},{oneOfNodeTypes:["Declaration"]})):(0,p.assertNodeType)("Declaration")}},E,{specifiers:{default:[],validate:(0,p.arrayOf)(function(){let e=(0,p.assertNodeType)("ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"),t=(0,p.assertNodeType)("ExportSpecifier");return i.env.BABEL_TYPES_8_BREAKING?Object.assign(function(a,i,r){(a.source?e:t)(a,i,r)},{oneOfNodeTypes:["ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"]}):e}())},source:{validate:(0,p.assertNodeType)("StringLiteral"),optional:!0},exportKind:(0,p.validateOptional)((0,p.assertOneOf)("type","value"))})}),d("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,p.assertNodeType)("Identifier")},exported:{validate:(0,p.assertNodeType)("Identifier","StringLiteral")},exportKind:{validate:(0,p.assertOneOf)("type","value"),optional:!0}}}),d("ForOfStatement",{visitor:["left","right","body"],builder:["left","right","body","await"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:function(){if(!i.env.BABEL_TYPES_8_BREAKING)return(0,p.assertNodeType)("VariableDeclaration","LVal");let e=(0,p.assertNodeType)("VariableDeclaration"),t=(0,p.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression");return Object.assign(function(a,i,s){(0,r.default)("VariableDeclaration",s)?e(a,i,s):t(a,i,s)},{oneOfNodeTypes:["VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"]})}()},right:{validate:(0,p.assertNodeType)("Expression")},body:{validate:(0,p.assertNodeType)("Statement")},await:{default:!1}}}),d("ImportDeclaration",{builder:["specifiers","source"],visitor:["specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration"],fields:Object.assign({},E,{module:{optional:!0,validate:(0,p.assertValueType)("boolean")},phase:{default:null,validate:(0,p.assertOneOf)("source","defer")},specifiers:(0,p.validateArrayOfType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier"),source:{validate:(0,p.assertNodeType)("StringLiteral")},importKind:{validate:(0,p.assertOneOf)("type","typeof","value"),optional:!0}})}),d("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,p.assertNodeType)("Identifier")}}}),d("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,p.assertNodeType)("Identifier")}}}),d("ImportSpecifier",{visitor:["imported","local"],builder:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,p.assertNodeType)("Identifier")},imported:{validate:(0,p.assertNodeType)("Identifier","StringLiteral")},importKind:{validate:(0,p.assertOneOf)("type","typeof","value"),optional:!0}}}),d("ImportExpression",{visitor:["source","options"],aliases:["Expression"],fields:{phase:{default:null,validate:(0,p.assertOneOf)("source","defer")},source:{validate:(0,p.assertNodeType)("Expression")},options:{validate:(0,p.assertNodeType)("Expression"),optional:!0}}}),d("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertNodeType)("Identifier"),Object.assign(function(e,t,a){let i;switch(a.name){case"function":i="sent";break;case"new":i="target";break;case"import":i="meta"}if(!(0,r.default)("Identifier",e.property,{name:i}))throw TypeError("Unrecognised MetaProperty")},{oneOfNodeTypes:["Identifier"]})):(0,p.assertNodeType)("Identifier")},property:{validate:(0,p.assertNodeType)("Identifier")}}});let f=()=>({abstract:{validate:(0,p.assertValueType)("boolean"),optional:!0},accessibility:{validate:(0,p.assertOneOf)("public","private","protected"),optional:!0},static:{default:!1},override:{default:!1},computed:{default:!1},optional:{validate:(0,p.assertValueType)("boolean"),optional:!0},key:{validate:(0,p.chain)(function(){let e=(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),t=(0,p.assertNodeType)("Expression");return function(a,i,r){(a.computed?t:e)(a,i,r)}}(),(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","Expression"))}});t.classMethodOrPropertyCommon=f;let S=()=>Object.assign({},y(),f(),{params:(0,p.validateArrayOfType)("Identifier","Pattern","RestElement","TSParameterProperty"),kind:{validate:(0,p.assertOneOf)("get","set","method","constructor"),default:"method"},access:{validate:(0,p.chain)((0,p.assertValueType)("string"),(0,p.assertOneOf)("public","private","protected")),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0}});t.classMethodOrDeclareMethodCommon=S,d("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},S(),T(),{body:{validate:(0,p.assertNodeType)("BlockStatement")}})}),d("ObjectPattern",{visitor:["properties","typeAnnotation","decorators"],builder:["properties"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},c(),{properties:(0,p.validateArrayOfType)("RestElement","ObjectProperty")})}),d("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],deprecatedAlias:"SpreadProperty",fields:{argument:{validate:(0,p.assertNodeType)("Expression")}}}),d("Super",{aliases:["Expression"]}),d("TaggedTemplateExpression",{visitor:["tag","typeParameters","quasi"],builder:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0,p.assertNodeType)("Expression")},quasi:{validate:(0,p.assertNodeType)("TemplateLiteral")},typeParameters:{validate:(0,p.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}}),d("TemplateElement",{builder:["value","tail"],fields:{value:{validate:(0,p.chain)((0,p.assertShape)({raw:{validate:(0,p.assertValueType)("string")},cooked:{validate:(0,p.assertValueType)("string"),optional:!0}}),function(e){let t=e.value.raw,a=!1,i=()=>{throw Error("Internal @babel/types error.")},{str:r,firstInvalidLoc:s}=(0,n.readStringContents)("template",t,0,0,0,{unterminated(){a=!0},strictNumericEscape:i,invalidEscapeSequence:i,numericSeparatorInEscapeSequence:i,unexpectedNumericSeparator:i,invalidDigit:i,invalidCodePoint:i});if(!a)throw Error("Invalid raw");e.value.cooked=s?null:r})},tail:{default:!1}}}),d("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:(0,p.validateArrayOfType)("TemplateElement"),expressions:{validate:(0,p.chain)((0,p.assertValueType)("array"),(0,p.assertEach)((0,p.assertNodeType)("Expression","TSType")),function(e,t,a){if(e.quasis.length!==a.length+1)throw TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${a.length+1} quasis but got ${e.quasis.length}`)})}}}),d("YieldExpression",{builder:["argument","delegate"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{delegate:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("boolean"),Object.assign(function(e,t,a){if(a&&!e.argument)throw TypeError("Property delegate of YieldExpression cannot be true if there is no argument")},{type:"boolean"})):(0,p.assertValueType)("boolean"),default:!1},argument:{optional:!0,validate:(0,p.assertNodeType)("Expression")}}}),d("AwaitExpression",{builder:["argument"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{argument:{validate:(0,p.assertNodeType)("Expression")}}}),d("Import",{aliases:["Expression"]}),d("BigIntLiteral",{builder:["value"],fields:{value:{validate:(0,p.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),d("ExportNamespaceSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0,p.assertNodeType)("Identifier")}}}),d("OptionalMemberExpression",{builder:["object","property","computed","optional"],visitor:["object","property"],aliases:["Expression"],fields:{object:{validate:(0,p.assertNodeType)("Expression")},property:{validate:function(){let e=(0,p.assertNodeType)("Identifier"),t=(0,p.assertNodeType)("Expression");return Object.assign(function(a,i,r){(a.computed?t:e)(a,i,r)},{oneOfNodeTypes:["Expression","Identifier"]})}()},computed:{default:!1},optional:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("boolean"),(0,p.assertOptionalChainStart)()):(0,p.assertValueType)("boolean")}}}),d("OptionalCallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments","optional"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0,p.assertNodeType)("Expression")},arguments:(0,p.validateArrayOfType)("Expression","SpreadElement","ArgumentPlaceholder"),optional:{validate:i.env.BABEL_TYPES_8_BREAKING?(0,p.chain)((0,p.assertValueType)("boolean"),(0,p.assertOptionalChainStart)()):(0,p.assertValueType)("boolean")},typeArguments:{validate:(0,p.assertNodeType)("TypeParameterInstantiation"),optional:!0}},{typeParameters:{validate:(0,p.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}})}),d("ClassProperty",{visitor:["decorators","variance","key","typeAnnotation","value"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property"],fields:Object.assign({},f(),{value:{validate:(0,p.assertNodeType)("Expression"),optional:!0},definite:{validate:(0,p.assertValueType)("boolean"),optional:!0},typeAnnotation:{validate:(0,p.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},readonly:{validate:(0,p.assertValueType)("boolean"),optional:!0},declare:{validate:(0,p.assertValueType)("boolean"),optional:!0},variance:{validate:(0,p.assertNodeType)("Variance"),optional:!0}})}),d("ClassAccessorProperty",{visitor:["decorators","key","typeAnnotation","value"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property","Accessor"],fields:Object.assign({},f(),{key:{validate:(0,p.chain)(function(){let e=(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","PrivateName"),t=(0,p.assertNodeType)("Expression");return function(a,i,r){(a.computed?t:e)(a,i,r)}}(),(0,p.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","Expression","PrivateName"))},value:{validate:(0,p.assertNodeType)("Expression"),optional:!0},definite:{validate:(0,p.assertValueType)("boolean"),optional:!0},typeAnnotation:{validate:(0,p.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},readonly:{validate:(0,p.assertValueType)("boolean"),optional:!0},declare:{validate:(0,p.assertValueType)("boolean"),optional:!0},variance:{validate:(0,p.assertNodeType)("Variance"),optional:!0}})}),d("ClassPrivateProperty",{visitor:["decorators","variance","key","typeAnnotation","value"],builder:["key","value","decorators","static"],aliases:["Property","Private"],fields:{key:{validate:(0,p.assertNodeType)("PrivateName")},value:{validate:(0,p.assertNodeType)("Expression"),optional:!0},typeAnnotation:{validate:(0,p.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0,p.arrayOfType)("Decorator"),optional:!0},static:{validate:(0,p.assertValueType)("boolean"),default:!1},readonly:{validate:(0,p.assertValueType)("boolean"),optional:!0},optional:{validate:(0,p.assertValueType)("boolean"),optional:!0},definite:{validate:(0,p.assertValueType)("boolean"),optional:!0},variance:{validate:(0,p.assertNodeType)("Variance"),optional:!0}}}),d("ClassPrivateMethod",{builder:["kind","key","params","body","static"],visitor:["decorators","key","typeParameters","params","returnType","body"],aliases:["Function","Scopable","BlockParent","FunctionParent","Method","Private"],fields:Object.assign({},S(),T(),{kind:{validate:(0,p.assertOneOf)("get","set","method"),default:"method"},key:{validate:(0,p.assertNodeType)("PrivateName")},body:{validate:(0,p.assertNodeType)("BlockStatement")}})}),d("PrivateName",{visitor:["id"],aliases:["Private"],fields:{id:{validate:(0,p.assertNodeType)("Identifier")}}}),d("StaticBlock",{visitor:["body"],fields:{body:(0,p.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","FunctionParent"]})},42286:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.DEPRECATED_ALIASES=void 0,t.DEPRECATED_ALIASES={ModuleDeclaration:"ImportOrExportDeclaration"}},58796:(e,t,a)=>{var i=a(2818),r=a(99875);(0,r.default)("ArgumentPlaceholder",{}),(0,r.default)("BindExpression",{visitor:["object","callee"],aliases:["Expression"],fields:i.env.BABEL_TYPES_8_BREAKING?{object:{validate:(0,r.assertNodeType)("Expression")},callee:{validate:(0,r.assertNodeType)("Expression")}}:{object:{validate:Object.assign(()=>{},{oneOfNodeTypes:["Expression"]})},callee:{validate:Object.assign(()=>{},{oneOfNodeTypes:["Expression"]})}}}),(0,r.default)("ImportAttribute",{visitor:["key","value"],fields:{key:{validate:(0,r.assertNodeType)("Identifier","StringLiteral")},value:{validate:(0,r.assertNodeType)("StringLiteral")}}}),(0,r.default)("Decorator",{visitor:["expression"],fields:{expression:{validate:(0,r.assertNodeType)("Expression")}}}),(0,r.default)("DoExpression",{visitor:["body"],builder:["body","async"],aliases:["Expression"],fields:{body:{validate:(0,r.assertNodeType)("BlockStatement")},async:{validate:(0,r.assertValueType)("boolean"),default:!1}}}),(0,r.default)("ExportDefaultSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0,r.assertNodeType)("Identifier")}}}),(0,r.default)("RecordExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:(0,r.validateArrayOfType)("ObjectProperty","SpreadElement")}}),(0,r.default)("TupleExpression",{fields:{elements:{validate:(0,r.arrayOfType)("Expression","SpreadElement"),default:[]}},visitor:["elements"],aliases:["Expression"]}),(0,r.default)("DecimalLiteral",{builder:["value"],fields:{value:{validate:(0,r.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0,r.default)("ModuleExpression",{visitor:["body"],fields:{body:{validate:(0,r.assertNodeType)("Program")}},aliases:["Expression"]}),(0,r.default)("TopicReference",{aliases:["Expression"]}),(0,r.default)("PipelineTopicExpression",{builder:["expression"],visitor:["expression"],fields:{expression:{validate:(0,r.assertNodeType)("Expression")}},aliases:["Expression"]}),(0,r.default)("PipelineBareFunction",{builder:["callee"],visitor:["callee"],fields:{callee:{validate:(0,r.assertNodeType)("Expression")}},aliases:["Expression"]}),(0,r.default)("PipelinePrimaryTopicReference",{aliases:["Expression"]})},22026:(e,t,a)=>{var i=a(84785),r=a(99875);let s=(0,r.defineAliasedType)("Flow"),o=e=>{let t="DeclareClass"===e;s(e,{builder:["id","typeParameters","extends","body"],visitor:["id","typeParameters","extends",...t?["mixins","implements"]:[],"body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),extends:(0,r.validateOptional)((0,r.arrayOfType)("InterfaceExtends"))},t?{mixins:(0,r.validateOptional)((0,r.arrayOfType)("InterfaceExtends")),implements:(0,r.validateOptional)((0,r.arrayOfType)("ClassImplements"))}:{},{body:(0,r.validateType)("ObjectTypeAnnotation")})})};s("AnyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("ArrayTypeAnnotation",{visitor:["elementType"],aliases:["FlowType"],fields:{elementType:(0,r.validateType)("FlowType")}}),s("BooleanTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("BooleanLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("NullLiteralTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("ClassImplements",{visitor:["id","typeParameters"],fields:{id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterInstantiation")}}),o("DeclareClass"),s("DeclareFunction",{builder:["id"],visitor:["id","predicate"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier"),predicate:(0,r.validateOptionalType)("DeclaredPredicate")}}),o("DeclareInterface"),s("DeclareModule",{builder:["id","body","kind"],visitor:["id","body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier","StringLiteral"),body:(0,r.validateType)("BlockStatement"),kind:(0,r.validateOptional)((0,r.assertOneOf)("CommonJS","ES"))}}),s("DeclareModuleExports",{visitor:["typeAnnotation"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{typeAnnotation:(0,r.validateType)("TypeAnnotation")}}),s("DeclareTypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),right:(0,r.validateType)("FlowType")}}),s("DeclareOpaqueType",{visitor:["id","typeParameters","supertype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),supertype:(0,r.validateOptionalType)("FlowType"),impltype:(0,r.validateOptionalType)("FlowType")}}),s("DeclareVariable",{visitor:["id"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier")}}),s("DeclareExportDeclaration",{visitor:["declaration","specifiers","source","attributes"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({declaration:(0,r.validateOptionalType)("Flow"),specifiers:(0,r.validateOptional)((0,r.arrayOfType)("ExportSpecifier","ExportNamespaceSpecifier")),source:(0,r.validateOptionalType)("StringLiteral"),default:(0,r.validateOptional)((0,r.assertValueType)("boolean"))},i.importAttributes)}),s("DeclareExportAllDeclaration",{visitor:["source","attributes"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({source:(0,r.validateType)("StringLiteral"),exportKind:(0,r.validateOptional)((0,r.assertOneOf)("type","value"))},i.importAttributes)}),s("DeclaredPredicate",{visitor:["value"],aliases:["FlowPredicate"],fields:{value:(0,r.validateType)("Flow")}}),s("ExistsTypeAnnotation",{aliases:["FlowType"]}),s("FunctionTypeAnnotation",{builder:["typeParameters","params","rest","returnType"],visitor:["typeParameters","this","params","rest","returnType"],aliases:["FlowType"],fields:{typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),params:(0,r.validateArrayOfType)("FunctionTypeParam"),rest:(0,r.validateOptionalType)("FunctionTypeParam"),this:(0,r.validateOptionalType)("FunctionTypeParam"),returnType:(0,r.validateType)("FlowType")}}),s("FunctionTypeParam",{visitor:["name","typeAnnotation"],fields:{name:(0,r.validateOptionalType)("Identifier"),typeAnnotation:(0,r.validateType)("FlowType"),optional:(0,r.validateOptional)((0,r.assertValueType)("boolean"))}}),s("GenericTypeAnnotation",{visitor:["id","typeParameters"],aliases:["FlowType"],fields:{id:(0,r.validateType)("Identifier","QualifiedTypeIdentifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterInstantiation")}}),s("InferredPredicate",{aliases:["FlowPredicate"]}),s("InterfaceExtends",{visitor:["id","typeParameters"],fields:{id:(0,r.validateType)("Identifier","QualifiedTypeIdentifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterInstantiation")}}),o("InterfaceDeclaration"),s("InterfaceTypeAnnotation",{visitor:["extends","body"],aliases:["FlowType"],fields:{extends:(0,r.validateOptional)((0,r.arrayOfType)("InterfaceExtends")),body:(0,r.validateType)("ObjectTypeAnnotation")}}),s("IntersectionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0,r.validate)((0,r.arrayOfType)("FlowType"))}}),s("MixedTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("EmptyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("NullableTypeAnnotation",{visitor:["typeAnnotation"],aliases:["FlowType"],fields:{typeAnnotation:(0,r.validateType)("FlowType")}}),s("NumberLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0,r.validate)((0,r.assertValueType)("number"))}}),s("NumberTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("ObjectTypeAnnotation",{visitor:["properties","indexers","callProperties","internalSlots"],aliases:["FlowType"],builder:["properties","indexers","callProperties","internalSlots","exact"],fields:{properties:(0,r.validate)((0,r.arrayOfType)("ObjectTypeProperty","ObjectTypeSpreadProperty")),indexers:{validate:(0,r.arrayOfType)("ObjectTypeIndexer"),optional:!0,default:[]},callProperties:{validate:(0,r.arrayOfType)("ObjectTypeCallProperty"),optional:!0,default:[]},internalSlots:{validate:(0,r.arrayOfType)("ObjectTypeInternalSlot"),optional:!0,default:[]},exact:{validate:(0,r.assertValueType)("boolean"),default:!1},inexact:(0,r.validateOptional)((0,r.assertValueType)("boolean"))}}),s("ObjectTypeInternalSlot",{visitor:["id","value"],builder:["id","value","optional","static","method"],aliases:["UserWhitespacable"],fields:{id:(0,r.validateType)("Identifier"),value:(0,r.validateType)("FlowType"),optional:(0,r.validate)((0,r.assertValueType)("boolean")),static:(0,r.validate)((0,r.assertValueType)("boolean")),method:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("ObjectTypeCallProperty",{visitor:["value"],aliases:["UserWhitespacable"],fields:{value:(0,r.validateType)("FlowType"),static:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("ObjectTypeIndexer",{visitor:["variance","id","key","value"],builder:["id","key","value","variance"],aliases:["UserWhitespacable"],fields:{id:(0,r.validateOptionalType)("Identifier"),key:(0,r.validateType)("FlowType"),value:(0,r.validateType)("FlowType"),static:(0,r.validate)((0,r.assertValueType)("boolean")),variance:(0,r.validateOptionalType)("Variance")}}),s("ObjectTypeProperty",{visitor:["key","value","variance"],aliases:["UserWhitespacable"],fields:{key:(0,r.validateType)("Identifier","StringLiteral"),value:(0,r.validateType)("FlowType"),kind:(0,r.validate)((0,r.assertOneOf)("init","get","set")),static:(0,r.validate)((0,r.assertValueType)("boolean")),proto:(0,r.validate)((0,r.assertValueType)("boolean")),optional:(0,r.validate)((0,r.assertValueType)("boolean")),variance:(0,r.validateOptionalType)("Variance"),method:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("ObjectTypeSpreadProperty",{visitor:["argument"],aliases:["UserWhitespacable"],fields:{argument:(0,r.validateType)("FlowType")}}),s("OpaqueType",{visitor:["id","typeParameters","supertype","impltype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),supertype:(0,r.validateOptionalType)("FlowType"),impltype:(0,r.validateType)("FlowType")}}),s("QualifiedTypeIdentifier",{visitor:["qualification","id"],builder:["id","qualification"],fields:{id:(0,r.validateType)("Identifier"),qualification:(0,r.validateType)("Identifier","QualifiedTypeIdentifier")}}),s("StringLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0,r.validate)((0,r.assertValueType)("string"))}}),s("StringTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("SymbolTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("ThisTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("TupleTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0,r.validate)((0,r.arrayOfType)("FlowType"))}}),s("TypeofTypeAnnotation",{visitor:["argument"],aliases:["FlowType"],fields:{argument:(0,r.validateType)("FlowType")}}),s("TypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0,r.validateType)("Identifier"),typeParameters:(0,r.validateOptionalType)("TypeParameterDeclaration"),right:(0,r.validateType)("FlowType")}}),s("TypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:(0,r.validateType)("FlowType")}}),s("TypeCastExpression",{visitor:["expression","typeAnnotation"],aliases:["ExpressionWrapper","Expression"],fields:{expression:(0,r.validateType)("Expression"),typeAnnotation:(0,r.validateType)("TypeAnnotation")}}),s("TypeParameter",{visitor:["bound","default","variance"],fields:{name:(0,r.validate)((0,r.assertValueType)("string")),bound:(0,r.validateOptionalType)("TypeAnnotation"),default:(0,r.validateOptionalType)("FlowType"),variance:(0,r.validateOptionalType)("Variance")}}),s("TypeParameterDeclaration",{visitor:["params"],fields:{params:(0,r.validate)((0,r.arrayOfType)("TypeParameter"))}}),s("TypeParameterInstantiation",{visitor:["params"],fields:{params:(0,r.validate)((0,r.arrayOfType)("FlowType"))}}),s("UnionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0,r.validate)((0,r.arrayOfType)("FlowType"))}}),s("Variance",{builder:["kind"],fields:{kind:(0,r.validate)((0,r.assertOneOf)("minus","plus"))}}),s("VoidTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),s("EnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{id:(0,r.validateType)("Identifier"),body:(0,r.validateType)("EnumBooleanBody","EnumNumberBody","EnumStringBody","EnumSymbolBody")}}),s("EnumBooleanBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0,r.validate)((0,r.assertValueType)("boolean")),members:(0,r.validateArrayOfType)("EnumBooleanMember"),hasUnknownMembers:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("EnumNumberBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0,r.validate)((0,r.assertValueType)("boolean")),members:(0,r.validateArrayOfType)("EnumNumberMember"),hasUnknownMembers:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("EnumStringBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0,r.validate)((0,r.assertValueType)("boolean")),members:(0,r.validateArrayOfType)("EnumStringMember","EnumDefaultedMember"),hasUnknownMembers:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("EnumSymbolBody",{aliases:["EnumBody"],visitor:["members"],fields:{members:(0,r.validateArrayOfType)("EnumDefaultedMember"),hasUnknownMembers:(0,r.validate)((0,r.assertValueType)("boolean"))}}),s("EnumBooleanMember",{aliases:["EnumMember"],builder:["id"],visitor:["id","init"],fields:{id:(0,r.validateType)("Identifier"),init:(0,r.validateType)("BooleanLiteral")}}),s("EnumNumberMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0,r.validateType)("Identifier"),init:(0,r.validateType)("NumericLiteral")}}),s("EnumStringMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0,r.validateType)("Identifier"),init:(0,r.validateType)("StringLiteral")}}),s("EnumDefaultedMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0,r.validateType)("Identifier")}}),s("IndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0,r.validateType)("FlowType"),indexType:(0,r.validateType)("FlowType")}}),s("OptionalIndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0,r.validateType)("FlowType"),indexType:(0,r.validateType)("FlowType"),optional:(0,r.validate)((0,r.assertValueType)("boolean"))}})},79398:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"ALIAS_KEYS",{enumerable:!0,get:function(){return i.ALIAS_KEYS}}),Object.defineProperty(t,"BUILDER_KEYS",{enumerable:!0,get:function(){return i.BUILDER_KEYS}}),Object.defineProperty(t,"DEPRECATED_ALIASES",{enumerable:!0,get:function(){return s.DEPRECATED_ALIASES}}),Object.defineProperty(t,"DEPRECATED_KEYS",{enumerable:!0,get:function(){return i.DEPRECATED_KEYS}}),Object.defineProperty(t,"FLIPPED_ALIAS_KEYS",{enumerable:!0,get:function(){return i.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(t,"NODE_FIELDS",{enumerable:!0,get:function(){return i.NODE_FIELDS}}),Object.defineProperty(t,"NODE_PARENT_VALIDATIONS",{enumerable:!0,get:function(){return i.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(t,"PLACEHOLDERS",{enumerable:!0,get:function(){return r.PLACEHOLDERS}}),Object.defineProperty(t,"PLACEHOLDERS_ALIAS",{enumerable:!0,get:function(){return r.PLACEHOLDERS_ALIAS}}),Object.defineProperty(t,"PLACEHOLDERS_FLIPPED_ALIAS",{enumerable:!0,get:function(){return r.PLACEHOLDERS_FLIPPED_ALIAS}}),t.TYPES=void 0,Object.defineProperty(t,"VISITOR_KEYS",{enumerable:!0,get:function(){return i.VISITOR_KEYS}}),a(84785),a(22026),a(31579),a(49938),a(58796),a(38989);var i=a(99875),r=a(7880),s=a(42286);Object.keys(s.DEPRECATED_ALIASES).forEach(e=>{i.FLIPPED_ALIAS_KEYS[e]=i.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[e]]}),t.TYPES=[].concat(Object.keys(i.VISITOR_KEYS),Object.keys(i.FLIPPED_ALIAS_KEYS),Object.keys(i.DEPRECATED_KEYS))},31579:(e,t,a)=>{var i=a(99875);let r=(0,i.defineAliasedType)("JSX");r("JSXAttribute",{visitor:["name","value"],aliases:["Immutable"],fields:{name:{validate:(0,i.assertNodeType)("JSXIdentifier","JSXNamespacedName")},value:{optional:!0,validate:(0,i.assertNodeType)("JSXElement","JSXFragment","StringLiteral","JSXExpressionContainer")}}}),r("JSXClosingElement",{visitor:["name"],aliases:["Immutable"],fields:{name:{validate:(0,i.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")}}}),r("JSXElement",{builder:["openingElement","closingElement","children","selfClosing"],visitor:["openingElement","children","closingElement"],aliases:["Immutable","Expression"],fields:Object.assign({openingElement:{validate:(0,i.assertNodeType)("JSXOpeningElement")},closingElement:{optional:!0,validate:(0,i.assertNodeType)("JSXClosingElement")},children:(0,i.validateArrayOfType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")},{selfClosing:{validate:(0,i.assertValueType)("boolean"),optional:!0}})}),r("JSXEmptyExpression",{}),r("JSXExpressionContainer",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0,i.assertNodeType)("Expression","JSXEmptyExpression")}}}),r("JSXSpreadChild",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0,i.assertNodeType)("Expression")}}}),r("JSXIdentifier",{builder:["name"],fields:{name:{validate:(0,i.assertValueType)("string")}}}),r("JSXMemberExpression",{visitor:["object","property"],fields:{object:{validate:(0,i.assertNodeType)("JSXMemberExpression","JSXIdentifier")},property:{validate:(0,i.assertNodeType)("JSXIdentifier")}}}),r("JSXNamespacedName",{visitor:["namespace","name"],fields:{namespace:{validate:(0,i.assertNodeType)("JSXIdentifier")},name:{validate:(0,i.assertNodeType)("JSXIdentifier")}}}),r("JSXOpeningElement",{builder:["name","attributes","selfClosing"],visitor:["name","typeParameters","typeArguments","attributes"],aliases:["Immutable"],fields:Object.assign({name:{validate:(0,i.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")},selfClosing:{default:!1},attributes:(0,i.validateArrayOfType)("JSXAttribute","JSXSpreadAttribute"),typeArguments:{validate:(0,i.assertNodeType)("TypeParameterInstantiation"),optional:!0}},{typeParameters:{validate:(0,i.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}})}),r("JSXSpreadAttribute",{visitor:["argument"],fields:{argument:{validate:(0,i.assertNodeType)("Expression")}}}),r("JSXText",{aliases:["Immutable"],builder:["value"],fields:{value:{validate:(0,i.assertValueType)("string")}}}),r("JSXFragment",{builder:["openingFragment","closingFragment","children"],visitor:["openingFragment","children","closingFragment"],aliases:["Immutable","Expression"],fields:{openingFragment:{validate:(0,i.assertNodeType)("JSXOpeningFragment")},closingFragment:{validate:(0,i.assertNodeType)("JSXClosingFragment")},children:(0,i.validateArrayOfType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")}}),r("JSXOpeningFragment",{aliases:["Immutable"]}),r("JSXClosingFragment",{aliases:["Immutable"]})},49938:(e,t,a)=>{var i=a(99875),r=a(7880),s=a(84785);let o=(0,i.defineAliasedType)("Miscellaneous");o("Noop",{visitor:[]}),o("Placeholder",{visitor:[],builder:["expectedNode","name"],fields:Object.assign({name:{validate:(0,i.assertNodeType)("Identifier")},expectedNode:{validate:(0,i.assertOneOf)(...r.PLACEHOLDERS)}},(0,s.patternLikeCommon)())}),o("V8IntrinsicIdentifier",{builder:["name"],fields:{name:{validate:(0,i.assertValueType)("string")}}})},7880:(e,t,a)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PLACEHOLDERS_FLIPPED_ALIAS=t.PLACEHOLDERS_ALIAS=t.PLACEHOLDERS=void 0;var i=a(99875);let r=t.PLACEHOLDERS=["Identifier","StringLiteral","Expression","Statement","Declaration","BlockStatement","ClassBody","Pattern"],s=t.PLACEHOLDERS_ALIAS={Declaration:["Statement"],Pattern:["PatternLike","LVal"]};for(let e of r){let t=i.ALIAS_KEYS[e];null!=t&&t.length&&(s[e]=t)}let o=t.PLACEHOLDERS_FLIPPED_ALIAS={};Object.keys(s).forEach(e=>{s[e].forEach(t=>{hasOwnProperty.call(o,t)||(o[t]=[]),o[t].push(e)})})},38989:(e,t,a)=>{var i=a(99875),r=a(84785),s=a(64039);let o=(0,i.defineAliasedType)("TypeScript"),n=(0,i.assertValueType)("boolean"),l=()=>({returnType:{validate:(0,i.assertNodeType)("TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0,i.assertNodeType)("TSTypeParameterDeclaration","Noop"),optional:!0}});o("TSParameterProperty",{aliases:["LVal"],visitor:["parameter"],fields:{accessibility:{validate:(0,i.assertOneOf)("public","private","protected"),optional:!0},readonly:{validate:(0,i.assertValueType)("boolean"),optional:!0},parameter:{validate:(0,i.assertNodeType)("Identifier","AssignmentPattern")},override:{validate:(0,i.assertValueType)("boolean"),optional:!0},decorators:{validate:(0,i.arrayOfType)("Decorator"),optional:!0}}}),o("TSDeclareFunction",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","params","returnType"],fields:Object.assign({},(0,r.functionDeclarationCommon)(),l())}),o("TSDeclareMethod",{visitor:["decorators","key","typeParameters","params","returnType"],fields:Object.assign({},(0,r.classMethodOrDeclareMethodCommon)(),l())}),o("TSQualifiedName",{aliases:["TSEntityName"],visitor:["left","right"],fields:{left:(0,i.validateType)("TSEntityName"),right:(0,i.validateType)("Identifier")}});let p=()=>({typeParameters:(0,i.validateOptionalType)("TSTypeParameterDeclaration"),parameters:(0,i.validateArrayOfType)("ArrayPattern","Identifier","ObjectPattern","RestElement"),typeAnnotation:(0,i.validateOptionalType)("TSTypeAnnotation")}),d={aliases:["TSTypeElement"],visitor:["typeParameters","parameters","typeAnnotation"],fields:p()};o("TSCallSignatureDeclaration",d),o("TSConstructSignatureDeclaration",d);let y=()=>({key:(0,i.validateType)("Expression"),computed:{default:!1},optional:(0,i.validateOptional)(n)});for(let e of(o("TSPropertySignature",{aliases:["TSTypeElement"],visitor:["key","typeAnnotation"],fields:Object.assign({},y(),{readonly:(0,i.validateOptional)(n),typeAnnotation:(0,i.validateOptionalType)("TSTypeAnnotation"),kind:{optional:!0,validate:(0,i.assertOneOf)("get","set")}})}),o("TSMethodSignature",{aliases:["TSTypeElement"],visitor:["key","typeParameters","parameters","typeAnnotation"],fields:Object.assign({},p(),y(),{kind:{validate:(0,i.assertOneOf)("method","get","set")}})}),o("TSIndexSignature",{aliases:["TSTypeElement"],visitor:["parameters","typeAnnotation"],fields:{readonly:(0,i.validateOptional)(n),static:(0,i.validateOptional)(n),parameters:(0,i.validateArrayOfType)("Identifier"),typeAnnotation:(0,i.validateOptionalType)("TSTypeAnnotation")}}),["TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword"]))o(e,{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});o("TSThisType",{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});let T={aliases:["TSType"],visitor:["typeParameters","parameters","typeAnnotation"]};o("TSFunctionType",Object.assign({},T,{fields:p()})),o("TSConstructorType",Object.assign({},T,{fields:Object.assign({},p(),{abstract:(0,i.validateOptional)(n)})})),o("TSTypeReference",{aliases:["TSType"],visitor:["typeName","typeParameters"],fields:{typeName:(0,i.validateType)("TSEntityName"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterInstantiation")}}),o("TSTypePredicate",{aliases:["TSType"],visitor:["parameterName","typeAnnotation"],builder:["parameterName","typeAnnotation","asserts"],fields:{parameterName:(0,i.validateType)("Identifier","TSThisType"),typeAnnotation:(0,i.validateOptionalType)("TSTypeAnnotation"),asserts:(0,i.validateOptional)(n)}}),o("TSTypeQuery",{aliases:["TSType"],visitor:["exprName","typeParameters"],fields:{exprName:(0,i.validateType)("TSEntityName","TSImportType"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterInstantiation")}}),o("TSTypeLiteral",{aliases:["TSType"],visitor:["members"],fields:{members:(0,i.validateArrayOfType)("TSTypeElement")}}),o("TSArrayType",{aliases:["TSType"],visitor:["elementType"],fields:{elementType:(0,i.validateType)("TSType")}}),o("TSTupleType",{aliases:["TSType"],visitor:["elementTypes"],fields:{elementTypes:(0,i.validateArrayOfType)("TSType","TSNamedTupleMember")}}),o("TSOptionalType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0,i.validateType)("TSType")}}),o("TSRestType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0,i.validateType)("TSType")}}),o("TSNamedTupleMember",{visitor:["label","elementType"],builder:["label","elementType","optional"],fields:{label:(0,i.validateType)("Identifier"),optional:{validate:n,default:!1},elementType:(0,i.validateType)("TSType")}});let u={aliases:["TSType"],visitor:["types"],fields:{types:(0,i.validateArrayOfType)("TSType")}};o("TSUnionType",u),o("TSIntersectionType",u),o("TSConditionalType",{aliases:["TSType"],visitor:["checkType","extendsType","trueType","falseType"],fields:{checkType:(0,i.validateType)("TSType"),extendsType:(0,i.validateType)("TSType"),trueType:(0,i.validateType)("TSType"),falseType:(0,i.validateType)("TSType")}}),o("TSInferType",{aliases:["TSType"],visitor:["typeParameter"],fields:{typeParameter:(0,i.validateType)("TSTypeParameter")}}),o("TSParenthesizedType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0,i.validateType)("TSType")}}),o("TSTypeOperator",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{operator:(0,i.validate)((0,i.assertValueType)("string")),typeAnnotation:(0,i.validateType)("TSType")}}),o("TSIndexedAccessType",{aliases:["TSType"],visitor:["objectType","indexType"],fields:{objectType:(0,i.validateType)("TSType"),indexType:(0,i.validateType)("TSType")}}),o("TSMappedType",{aliases:["TSType"],visitor:["typeParameter","nameType","typeAnnotation"],builder:["typeParameter","typeAnnotation","nameType"],fields:Object.assign({},{typeParameter:(0,i.validateType)("TSTypeParameter")},{readonly:(0,i.validateOptional)((0,i.assertOneOf)(!0,!1,"+","-")),optional:(0,i.validateOptional)((0,i.assertOneOf)(!0,!1,"+","-")),typeAnnotation:(0,i.validateOptionalType)("TSType"),nameType:(0,i.validateOptionalType)("TSType")})}),o("TSTemplateLiteralType",{aliases:["TSType","TSBaseType"],visitor:["quasis","types"],fields:{quasis:(0,i.validateArrayOfType)("TemplateElement"),types:{validate:(0,i.chain)((0,i.assertValueType)("array"),(0,i.assertEach)((0,i.assertNodeType)("TSType")),function(e,t,a){if(e.quasis.length!==a.length+1)throw TypeError(`Number of ${e.type} quasis should be exactly one more than the number of types.
Expected ${a.length+1} quasis but got ${e.quasis.length}`)})}}}),o("TSLiteralType",{aliases:["TSType","TSBaseType"],visitor:["literal"],fields:{literal:{validate:function(){let e=(0,i.assertNodeType)("NumericLiteral","BigIntLiteral"),t=(0,i.assertOneOf)("-"),a=(0,i.assertNodeType)("NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral","TemplateLiteral");function r(i,r,o){(0,s.default)("UnaryExpression",o)?(t(o,"operator",o.operator),e(o,"argument",o.argument)):a(i,r,o)}return r.oneOfNodeTypes=["NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral","TemplateLiteral","UnaryExpression"],r}()}}}),o("TSExpressionWithTypeArguments",{aliases:["TSType"],visitor:["expression","typeParameters"],fields:{expression:(0,i.validateType)("TSEntityName"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterInstantiation")}}),o("TSInterfaceDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","extends","body"],fields:{declare:(0,i.validateOptional)(n),id:(0,i.validateType)("Identifier"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterDeclaration"),extends:(0,i.validateOptional)((0,i.arrayOfType)("TSExpressionWithTypeArguments")),body:(0,i.validateType)("TSInterfaceBody")}}),o("TSInterfaceBody",{visitor:["body"],fields:{body:(0,i.validateArrayOfType)("TSTypeElement")}}),o("TSTypeAliasDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","typeAnnotation"],fields:{declare:(0,i.validateOptional)(n),id:(0,i.validateType)("Identifier"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterDeclaration"),typeAnnotation:(0,i.validateType)("TSType")}}),o("TSInstantiationExpression",{aliases:["Expression"],visitor:["expression","typeParameters"],fields:{expression:(0,i.validateType)("Expression"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterInstantiation")}});let c={aliases:["Expression","LVal","PatternLike"],visitor:["expression","typeAnnotation"],fields:{expression:(0,i.validateType)("Expression"),typeAnnotation:(0,i.validateType)("TSType")}};o("TSAsExpression",c),o("TSSatisfiesExpression",c),o("TSTypeAssertion",{aliases:["Expression","LVal","PatternLike"],visitor:["typeAnnotation","expression"],fields:{typeAnnotation:(0,i.validateType)("TSType"),expression:(0,i.validateType)("Expression")}}),o("TSEnumBody",{visitor:["members"],fields:{members:(0,i.validateArrayOfType)("TSEnumMember")}}),o("TSEnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","members"],fields:{declare:(0,i.validateOptional)(n),const:(0,i.validateOptional)(n),id:(0,i.validateType)("Identifier"),members:(0,i.validateArrayOfType)("TSEnumMember"),initializer:(0,i.validateOptionalType)("Expression"),body:(0,i.validateOptionalType)("TSEnumBody")}}),o("TSEnumMember",{visitor:["id","initializer"],fields:{id:(0,i.validateType)("Identifier","StringLiteral"),initializer:(0,i.validateOptionalType)("Expression")}}),o("TSModuleDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:Object.assign({kind:{validate:(0,i.assertOneOf)("global","module","namespace")},declare:(0,i.validateOptional)(n)},{global:(0,i.validateOptional)(n)},{id:(0,i.validateType)("Identifier","StringLiteral"),body:(0,i.validateType)("TSModuleBlock","TSModuleDeclaration")})}),o("TSModuleBlock",{aliases:["Scopable","Block","BlockParent","FunctionParent"],visitor:["body"],fields:{body:(0,i.validateArrayOfType)("Statement")}}),o("TSImportType",{aliases:["TSType"],builder:["argument","qualifier","typeParameters"],visitor:["argument","options","qualifier","typeParameters"],fields:{argument:(0,i.validateType)("StringLiteral"),qualifier:(0,i.validateOptionalType)("TSEntityName"),typeParameters:(0,i.validateOptionalType)("TSTypeParameterInstantiation"),options:{validate:(0,i.assertNodeType)("Expression"),optional:!0}}}),o("TSImportEqualsDeclaration",{aliases:["Statement","Declaration"],visitor:["id","moduleReference"],fields:Object.assign({},{isExport:(0,i.validate)(n)},{id:(0,i.validateType)("Identifier"),moduleReference:(0,i.validateType)("TSEntityName","TSExternalModuleReference"),importKind:{validate:(0,i.assertOneOf)("type","value"),optional:!0}})}),o("TSExternalModuleReference",{visitor:["expression"],fields:{expression:(0,i.validateType)("StringLiteral")}}),o("TSNonNullExpression",{aliases:["Expression","LVal","PatternLike"],visitor:["expression"],fields:{expression:(0,i.validateType)("Expression")}}),o("TSExportAssignment",{aliases:["Statement"],visitor:["expression"],fields:{expression:(0,i.validateType)("Expression")}}),o("TSNamespaceExportDeclaration",{aliases:["Statement"],visitor:["id"],fields:{id:(0,i.validateType)("Identifier")}}),o("TSTypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:{validate:(0,i.assertNodeType)("TSType")}}}),o("TSTypeParameterInstantiation",{visitor:["params"],fields:{params:(0,i.validateArrayOfType)("TSType")}}),o("TSTypeParameterDeclaration",{visitor:["params"],fields:{params:(0,i.validateArrayOfType)("TSTypeParameter")}}),o("TSTypeParameter",{builder:["constraint","default","name"],visitor:["constraint","default"],fields:{name:{validate:(0,i.assertValueType)("string")},in:{validate:(0,i.assertValueType)("boolean"),optional:!0},out:{validate:(0,i.assertValueType)("boolean"),optional:!0},const:{validate:(0,i.assertValueType)("boolean"),optional:!0},constraint:{validate:(0,i.assertNodeType)("TSType"),optional:!0},default:{validate:(0,i.assertNodeType)("TSType"),optional:!0}}})},99875:(e,t,a)=>{var i=a(2818);Object.defineProperty(t,"__esModule",{value:!0}),t.VISITOR_KEYS=t.NODE_PARENT_VALIDATIONS=t.NODE_FIELDS=t.FLIPPED_ALIAS_KEYS=t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.ALIAS_KEYS=void 0,t.arrayOf=E,t.arrayOfType=f,t.assertEach=S,t.assertNodeOrValueType=function(...e){function t(t,a,i){for(let o of e)if(u(i)===o||(0,r.default)(o,i)){(0,s.validateChild)(t,a,i);return}throw TypeError(`Property ${a} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==i?void 0:i.type)}`)}return t.oneOfNodeOrValueTypes=e,t},t.assertNodeType=v,t.assertOneOf=function(...e){function t(t,a,i){if(!e.includes(i))throw TypeError(`Property ${a} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(i)}`)}return t.oneOf=e,t},t.assertOptionalChainStart=function(){return function(e){var t;let a=e;for(;e;){let{type:e}=a;if("OptionalCallExpression"===e){if(a.optional)return;a=a.callee;continue}if("OptionalMemberExpression"===e){if(a.optional)return;a=a.object;continue}break}throw TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null==(t=a)?void 0:t.type}`)}},t.assertShape=function(e){function t(t,a,i){let r=[];for(let a of Object.keys(e))try{(0,s.validateField)(t,a,i[a],e[a])}catch(e){if(e instanceof TypeError){r.push(e.message);continue}throw e}if(r.length)throw TypeError(`Property ${a} of ${t.type} expected to have the following:
${r.join("\n")}`)}return t.shapeOf=e,t},t.assertValueType=m,t.chain=P,t.default=N,t.defineAliasedType=function(...e){return(t,a={})=>{let i=a.aliases;if(!i){var r;a.inherits&&(i=null==(r=b[a.inherits].aliases)?void 0:r.slice()),null!=i||(i=[]),a.aliases=i}let s=e.filter(e=>!i.includes(e));i.unshift(...s),N(t,a)}},t.validate=c,t.validateArrayOfType=function(...e){return c(f(...e))},t.validateOptional=function(e){return{validate:e,optional:!0}},t.validateOptionalType=function(...e){return{validate:v(...e),optional:!0}},t.validateType=function(...e){return c(v(...e))};var r=a(64039),s=a(41681);let o=t.VISITOR_KEYS={},n=t.ALIAS_KEYS={},l=t.FLIPPED_ALIAS_KEYS={},p=t.NODE_FIELDS={},d=t.BUILDER_KEYS={},y=t.DEPRECATED_KEYS={},T=t.NODE_PARENT_VALIDATIONS={};function u(e){return Array.isArray(e)?"array":null===e?"null":typeof e}function c(e){return{validate:e}}function E(e){return P(m("array"),S(e))}function f(...e){return E(v(...e))}function S(e){let t=i.env.BABEL_TYPES_8_BREAKING?s.validateChild:()=>{};function a(a,i,r){if(Array.isArray(r))for(let s=0;s<r.length;s++){let o=`${i}[${s}]`,n=r[s];e(a,o,n),t(a,o,n)}}return a.each=e,a}function v(...e){function t(t,a,i){for(let o of e)if((0,r.default)(o,i)){(0,s.validateChild)(t,a,i);return}throw TypeError(`Property ${a} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==i?void 0:i.type)}`)}return t.oneOfNodeTypes=e,t}function m(e){function t(t,a,i){if(u(i)!==e)throw TypeError(`Property ${a} expected type of ${e} but got ${u(i)}`)}return t.type=e,t}function P(...e){function t(...a){for(let t of e)t(...a)}if(t.chainOf=e,e.length>=2&&"type"in e[0]&&"array"===e[0].type&&!("each"in e[1]))throw Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');return t}let A=new Set(["aliases","builder","deprecatedAlias","fields","inherits","visitor","validate"]),O=new Set(["default","optional","deprecated","validate"]),b={};function N(e,t={}){let a=t.inherits&&b[t.inherits]||{},i=t.fields;if(!i&&(i={},a.fields))for(let e of Object.getOwnPropertyNames(a.fields)){let t=a.fields[e],r=t.default;if(Array.isArray(r)?r.length>0:r&&"object"==typeof r)throw Error("field defaults can only be primitives or empty arrays currently");i[e]={default:Array.isArray(r)?[]:r,optional:t.optional,deprecated:t.deprecated,validate:t.validate}}let r=t.visitor||a.visitor||[],s=t.aliases||a.aliases||[],c=t.builder||a.builder||t.visitor||[];for(let a of Object.keys(t))if(!A.has(a))throw Error(`Unknown type option "${a}" on ${e}`);for(let a of(t.deprecatedAlias&&(y[t.deprecatedAlias]=e),r.concat(c)))i[a]=i[a]||{};for(let t of Object.keys(i)){let a=i[t];for(let i of(void 0===a.default||c.includes(t)||(a.optional=!0),void 0===a.default?a.default=null:a.validate||null==a.default||(a.validate=m(u(a.default))),Object.keys(a)))if(!O.has(i))throw Error(`Unknown field key "${i}" on ${e}.${t}`)}o[e]=t.visitor=r,d[e]=t.builder=c,p[e]=t.fields=i,n[e]=t.aliases=s,s.forEach(t=>{l[t]=l[t]||[],l[t].push(e)}),t.validate&&(T[e]=t.validate),b[e]=t}}}]);